<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algorithm Comparison - clustering-tfjs</title>
  
  <!-- Load TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
  
  <!-- Load clustering-tfjs from unpkg CDN -->
  <script src="https://unpkg.com/clustering-tfjs@latest/dist/clustering.browser.js"></script>
  
  <!-- Load Plotly.js for visualization -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 10px;
    }
    
    .description {
      text-align: center;
      color: #666;
      margin-bottom: 30px;
    }
    
    .controls {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
      display: flex;
      gap: 20px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .control-item {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    label {
      font-weight: 500;
      color: #555;
    }
    
    select, button {
      padding: 8px 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    
    button {
      background-color: #007bff;
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: #0056b3;
    }
    
    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    
    .charts-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .chart-wrapper {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .chart-title {
      font-size: 18px;
      font-weight: 600;
      color: #333;
      margin-bottom: 10px;
      text-align: center;
    }
    
    .chart {
      width: 100%;
      height: 400px;
    }
    
    .metrics {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .metrics-title {
      font-size: 18px;
      font-weight: 600;
      color: #333;
      margin-bottom: 15px;
    }
    
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }
    
    .metric-item {
      padding: 15px;
      background: #f8f9fa;
      border-radius: 4px;
      text-align: center;
    }
    
    .metric-label {
      font-size: 14px;
      color: #666;
      margin-bottom: 5px;
    }
    
    .metric-value {
      font-size: 24px;
      font-weight: 600;
      color: #333;
    }
    
    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Clustering Algorithm Comparison</h1>
    <p class="description">Compare K-Means, Spectral, and Agglomerative clustering on the same dataset</p>
    
    <div class="controls">
      <div class="control-item">
        <label for="dataset">Dataset:</label>
        <select id="dataset">
          <option value="blobs">Gaussian Blobs</option>
          <option value="moons">Two Moons</option>
          <option value="circles">Concentric Circles</option>
          <option value="anisotropic">Anisotropic</option>
        </select>
      </div>
      
      <div class="control-item">
        <label for="nClusters">Clusters:</label>
        <select id="nClusters">
          <option value="2">2</option>
          <option value="3" selected>3</option>
          <option value="4">4</option>
          <option value="5">5</option>
        </select>
      </div>
      
      <button id="runButton" onclick="runComparison()">Run Comparison</button>
      <button onclick="generateNewData()">New Data</button>
    </div>
    
    <div class="charts-container">
      <div class="chart-wrapper">
        <div class="chart-title">Original Data</div>
        <div id="originalChart" class="chart"></div>
      </div>
      
      <div class="chart-wrapper">
        <div class="chart-title">K-Means Clustering</div>
        <div id="kmeansChart" class="chart"></div>
      </div>
      
      <div class="chart-wrapper">
        <div class="chart-title">Spectral Clustering</div>
        <div id="spectralChart" class="chart"></div>
      </div>
      
      <div class="chart-wrapper">
        <div class="chart-title">Agglomerative Clustering</div>
        <div id="agglomerativeChart" class="chart"></div>
      </div>
    </div>
    
    <div class="metrics">
      <div class="metrics-title">Performance Metrics</div>
      <div id="metricsGrid" class="metrics-grid">
        <div class="loading">Run comparison to see metrics</div>
      </div>
    </div>
  </div>

  <script>
    let data = [];
    let clustering = null;
    let initialized = false;
    
    // Color schemes
    const colorscale = [
      ['0', '#1f77b4'],
      ['0.25', '#ff7f0e'],
      ['0.5', '#2ca02c'],
      ['0.75', '#d62728'],
      ['1', '#9467bd']
    ];
    
    // Initialize clustering library
    async function initializeClustering() {
      if (initialized) return;
      
      try {
        const { Clustering } = window.ClusteringTFJS;
        await Clustering.init({ backend: 'cpu' });
        clustering = Clustering;
        initialized = true;
        console.log('Clustering library initialized');
      } catch (error) {
        console.error('Failed to initialize:', error);
      }
    }
    
    // Generate datasets
    function generateDataset(type, nSamples = 300) {
      const points = [];
      
      switch (type) {
        case 'blobs':
          const nClusters = parseInt(document.getElementById('nClusters').value);
          for (let i = 0; i < nClusters; i++) {
            const centerX = Math.random() * 6 + 2;
            const centerY = Math.random() * 6 + 2;
            const samplesPerCluster = Math.floor(nSamples / nClusters);
            
            for (let j = 0; j < samplesPerCluster; j++) {
              points.push([
                centerX + (Math.random() - 0.5) * 1.5,
                centerY + (Math.random() - 0.5) * 1.5
              ]);
            }
          }
          break;
          
        case 'moons':
          const noise = 0.15;
          for (let i = 0; i < nSamples / 2; i++) {
            const angle = Math.PI * i / (nSamples / 2);
            points.push([
              Math.cos(angle) + (Math.random() - 0.5) * noise,
              Math.sin(angle) + (Math.random() - 0.5) * noise
            ]);
            points.push([
              1 - Math.cos(angle) + (Math.random() - 0.5) * noise,
              0.5 - Math.sin(angle) + (Math.random() - 0.5) * noise
            ]);
          }
          break;
          
        case 'circles':
          for (let i = 0; i < nSamples / 2; i++) {
            const angle1 = 2 * Math.PI * Math.random();
            const angle2 = 2 * Math.PI * Math.random();
            points.push([
              2 * Math.cos(angle1) + 5,
              2 * Math.sin(angle1) + 5
            ]);
            points.push([
              4 * Math.cos(angle2) + 5,
              4 * Math.sin(angle2) + 5
            ]);
          }
          break;
          
        case 'anisotropic':
          for (let i = 0; i < 3; i++) {
            const angle = (i * 2 * Math.PI) / 3;
            const samplesPerCluster = Math.floor(nSamples / 3);
            
            for (let j = 0; j < samplesPerCluster; j++) {
              const t = (Math.random() - 0.5) * 3;
              const n = (Math.random() - 0.5) * 0.3;
              points.push([
                5 + t * Math.cos(angle) - n * Math.sin(angle),
                5 + t * Math.sin(angle) + n * Math.cos(angle)
              ]);
            }
          }
          break;
      }
      
      return points;
    }
    
    // Plot data
    function plotData(divId, data, labels = null, title = '') {
      const x = data.map(p => p[0]);
      const y = data.map(p => p[1]);
      
      const trace = {
        x: x,
        y: y,
        mode: 'markers',
        type: 'scatter',
        marker: {
          size: 8,
          color: labels || 'gray',
          colorscale: labels ? colorscale : undefined,
          line: {
            color: 'white',
            width: 0.5
          }
        }
      };
      
      const layout = {
        showlegend: false,
        hovermode: 'closest',
        margin: { l: 40, r: 40, t: 40, b: 40 },
        xaxis: { 
          zeroline: false,
          showgrid: true,
          gridcolor: '#f0f0f0'
        },
        yaxis: { 
          zeroline: false,
          showgrid: true,
          gridcolor: '#f0f0f0'
        },
        plot_bgcolor: '#fafafa'
      };
      
      Plotly.newPlot(divId, [trace], layout, { responsive: true });
    }
    
    // Run clustering comparison
    async function runComparison() {
      if (!initialized) {
        await initializeClustering();
      }
      
      if (data.length === 0) {
        generateNewData();
      }
      
      const nClusters = parseInt(document.getElementById('nClusters').value);
      const runButton = document.getElementById('runButton');
      
      runButton.disabled = true;
      runButton.textContent = 'Running...';
      
      const metrics = {};
      
      try {
        // K-Means
        const kmeansStart = performance.now();
        const kmeans = new clustering.KMeans({
          nClusters: nClusters,
          nInit: 10
        });
        await kmeans.fit(data);
        const kmeansLabels = await kmeans.predict(data);
        metrics.kmeans = performance.now() - kmeansStart;
        plotData('kmeansChart', data, kmeansLabels);
        
        // Spectral
        const spectralStart = performance.now();
        const spectral = new clustering.SpectralClustering({
          nClusters: nClusters,
          gamma: 1.0,
          affinity: 'rbf'
        });
        const spectralLabels = await spectral.fitPredict(data);
        metrics.spectral = performance.now() - spectralStart;
        plotData('spectralChart', data, spectralLabels);
        
        // Agglomerative
        const aggloStart = performance.now();
        const agglomerative = new clustering.AgglomerativeClustering({
          nClusters: nClusters,
          linkage: 'average'
        });
        const aggloLabels = await agglomerative.fitPredict(data);
        metrics.agglomerative = performance.now() - aggloStart;
        plotData('agglomerativeChart', data, aggloLabels);
        
        // Update metrics display
        updateMetrics(metrics, {
          kmeans: kmeansLabels,
          spectral: spectralLabels,
          agglomerative: aggloLabels
        });
        
      } catch (error) {
        console.error('Clustering failed:', error);
      } finally {
        runButton.disabled = false;
        runButton.textContent = 'Run Comparison';
      }
    }
    
    // Update metrics display
    function updateMetrics(timings, labels) {
      const metricsGrid = document.getElementById('metricsGrid');
      metricsGrid.innerHTML = '';
      
      // Add timing metrics
      ['kmeans', 'spectral', 'agglomerative'].forEach(algo => {
        const item = document.createElement('div');
        item.className = 'metric-item';
        item.innerHTML = `
          <div class="metric-label">${algo.charAt(0).toUpperCase() + algo.slice(1)} Time</div>
          <div class="metric-value">${timings[algo].toFixed(1)}ms</div>
        `;
        metricsGrid.appendChild(item);
      });
      
      // Add data info
      const dataInfo = document.createElement('div');
      dataInfo.className = 'metric-item';
      dataInfo.innerHTML = `
        <div class="metric-label">Data Points</div>
        <div class="metric-value">${data.length}</div>
      `;
      metricsGrid.appendChild(dataInfo);
    }
    
    // Generate new data
    function generateNewData() {
      const datasetType = document.getElementById('dataset').value;
      data = generateDataset(datasetType);
      
      // Plot original data
      plotData('originalChart', data);
      
      // Clear other charts
      ['kmeansChart', 'spectralChart', 'agglomerativeChart'].forEach(id => {
        Plotly.purge(id);
        document.getElementById(id).innerHTML = '<div class="loading">Click "Run Comparison" to see results</div>';
      });
      
      // Reset metrics
      document.getElementById('metricsGrid').innerHTML = '<div class="loading">Run comparison to see metrics</div>';
    }
    
    // Initialize on load
    window.addEventListener('load', async function() {
      await initializeClustering();
      generateNewData();
    });
  </script>
</body>
</html>