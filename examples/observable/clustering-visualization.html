<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clustering Visualization - clustering-tfjs</title>
  
  <!-- Load TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
  
  <!-- Load clustering-tfjs from unpkg CDN -->
  <script src="https://unpkg.com/clustering-tfjs@latest/dist/clustering.browser.js"></script>
  
  <!-- Load D3.js for visualization -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    h1 {
      margin-top: 0;
      color: #333;
    }
    
    .controls {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      align-items: flex-start;
    }
    
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    label {
      font-weight: 500;
      color: #555;
      font-size: 14px;
    }
    
    select, input[type="range"], button {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    
    input[type="range"] {
      width: 200px;
    }
    
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: #45a049;
    }
    
    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    
    .visualization-container {
      display: flex;
      gap: 20px;
      margin-top: 20px;
    }
    
    .chart {
      flex: 1;
      background: #fafafa;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 10px;
    }
    
    svg {
      width: 100%;
      height: 100%;
    }
    
    .info {
      margin-top: 20px;
      padding: 15px;
      background-color: #f0f8ff;
      border-radius: 4px;
      font-size: 14px;
      color: #333;
    }
    
    .legend {
      display: flex;
      gap: 15px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
    }
    
    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 1px solid #ddd;
    }
    
    .loading {
      text-align: center;
      padding: 20px;
      color: #666;
    }
    
    .range-value {
      font-weight: normal;
      color: #666;
      margin-left: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Interactive Clustering Visualization</h1>
    <p>Explore different clustering algorithms with interactive controls and real-time visualization.</p>
    
    <div class="controls">
      <div class="control-group">
        <label for="dataset">Dataset:</label>
        <select id="dataset">
          <option value="blobs">Gaussian Blobs</option>
          <option value="moons">Two Moons</option>
          <option value="circles">Concentric Circles</option>
          <option value="anisotropic">Anisotropic</option>
        </select>
      </div>
      
      <div class="control-group">
        <label for="algorithm">Algorithm:</label>
        <select id="algorithm">
          <option value="kmeans">K-Means</option>
          <option value="spectral">Spectral Clustering</option>
          <option value="agglomerative">Agglomerative</option>
        </select>
      </div>
      
      <div class="control-group">
        <label for="nClusters">Number of Clusters: <span id="nClustersValue" class="range-value">3</span></label>
        <input type="range" id="nClusters" min="2" max="10" value="3">
      </div>
      
      <div class="control-group" id="gammaControl" style="display: none;">
        <label for="gamma">Gamma (RBF kernel): <span id="gammaValue" class="range-value">1.0</span></label>
        <input type="range" id="gamma" min="0.1" max="10" step="0.1" value="1.0">
      </div>
      
      <div class="control-group" id="linkageControl" style="display: none;">
        <label for="linkage">Linkage:</label>
        <select id="linkage">
          <option value="single">Single</option>
          <option value="complete">Complete</option>
          <option value="average">Average</option>
        </select>
      </div>
      
      <div class="control-group">
        <button id="runButton" onclick="runClustering()">Run Clustering</button>
        <button onclick="generateNewData()">New Data</button>
      </div>
    </div>
    
    <div class="visualization-container">
      <div class="chart" id="scatterChart">
        <div class="loading">Click "Run Clustering" to start</div>
      </div>
    </div>
    
    <div id="legend" class="legend"></div>
    
    <div class="info" id="info">
      <strong>Instructions:</strong>
      <ul>
        <li>Select a dataset type and clustering algorithm</li>
        <li>Adjust parameters using the controls</li>
        <li>Click "Run Clustering" to see the results</li>
        <li>Try different combinations to see how algorithms perform on various data patterns</li>
      </ul>
    </div>
  </div>

  <script>
    // Initialize global variables
    let data = [];
    let labels = [];
    let centroids = [];
    let clustering = null;
    let initialized = false;
    
    // Color palette (colorblind-friendly)
    const colors = [
      '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
      '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'
    ];
    
    // Initialize clustering library
    async function initializeClustering() {
      if (initialized) return;
      
      try {
        const { Clustering } = window.ClusteringTFJS;
        await Clustering.init({ backend: 'cpu' }); // Use CPU backend for CodePen
        clustering = Clustering;
        initialized = true;
        console.log('Clustering library initialized');
      } catch (error) {
        console.error('Failed to initialize clustering:', error);
        document.getElementById('info').innerHTML = 
          '<strong>Error:</strong> Failed to initialize clustering library. ' + error.message;
      }
    }
    
    // Generate synthetic datasets
    function generateData(type, nSamples = 200) {
      data = [];
      
      switch (type) {
        case 'blobs':
          // Generate gaussian blobs
          const nClusters = parseInt(document.getElementById('nClusters').value);
          for (let i = 0; i < nClusters; i++) {
            const centerX = Math.random() * 8 + 1;
            const centerY = Math.random() * 8 + 1;
            const samplesPerCluster = Math.floor(nSamples / nClusters);
            
            for (let j = 0; j < samplesPerCluster; j++) {
              data.push([
                centerX + (Math.random() - 0.5) * 2,
                centerY + (Math.random() - 0.5) * 2
              ]);
            }
          }
          break;
          
        case 'moons':
          // Generate two moons
          const noise = 0.1;
          for (let i = 0; i < nSamples / 2; i++) {
            const angle = Math.PI * i / (nSamples / 2);
            // First moon
            data.push([
              Math.cos(angle) + (Math.random() - 0.5) * noise,
              Math.sin(angle) + (Math.random() - 0.5) * noise
            ]);
            // Second moon (shifted and flipped)
            data.push([
              1 - Math.cos(angle) + (Math.random() - 0.5) * noise,
              0.5 - Math.sin(angle) + (Math.random() - 0.5) * noise
            ]);
          }
          break;
          
        case 'circles':
          // Generate concentric circles
          const innerRadius = 2;
          const outerRadius = 4;
          for (let i = 0; i < nSamples / 2; i++) {
            const angle1 = 2 * Math.PI * Math.random();
            const angle2 = 2 * Math.PI * Math.random();
            // Inner circle
            data.push([
              innerRadius * Math.cos(angle1) + 5,
              innerRadius * Math.sin(angle1) + 5
            ]);
            // Outer circle
            data.push([
              outerRadius * Math.cos(angle2) + 5,
              outerRadius * Math.sin(angle2) + 5
            ]);
          }
          break;
          
        case 'anisotropic':
          // Generate anisotropic (elongated) clusters
          for (let i = 0; i < 3; i++) {
            const angle = (i * 2 * Math.PI) / 3;
            const samplesPerCluster = Math.floor(nSamples / 3);
            
            for (let j = 0; j < samplesPerCluster; j++) {
              const t = (Math.random() - 0.5) * 4;
              const n = (Math.random() - 0.5) * 0.5;
              data.push([
                5 + t * Math.cos(angle) - n * Math.sin(angle),
                5 + t * Math.sin(angle) + n * Math.cos(angle)
              ]);
            }
          }
          break;
      }
      
      // Clear previous results
      labels = [];
      centroids = [];
      visualizeData();
    }
    
    // Run clustering algorithm
    async function runClustering() {
      if (!initialized) {
        await initializeClustering();
      }
      
      if (data.length === 0) {
        generateNewData();
      }
      
      const algorithm = document.getElementById('algorithm').value;
      const nClusters = parseInt(document.getElementById('nClusters').value);
      const runButton = document.getElementById('runButton');
      
      runButton.disabled = true;
      runButton.textContent = 'Running...';
      
      try {
        const startTime = performance.now();
        
        switch (algorithm) {
          case 'kmeans':
            const kmeans = new clustering.KMeans({ 
              nClusters: nClusters,
              nInit: 10
            });
            await kmeans.fit(data);
            labels = await kmeans.predict(data);
            centroids = kmeans.centroids_;
            break;
            
          case 'spectral':
            const gamma = parseFloat(document.getElementById('gamma').value);
            const spectral = new clustering.SpectralClustering({
              nClusters: nClusters,
              gamma: gamma,
              affinity: 'rbf'
            });
            labels = await spectral.fitPredict(data);
            centroids = [];
            break;
            
          case 'agglomerative':
            const linkage = document.getElementById('linkage').value;
            const agglomerative = new clustering.AgglomerativeClustering({
              nClusters: nClusters,
              linkage: linkage
            });
            labels = await agglomerative.fitPredict(data);
            centroids = [];
            break;
        }
        
        const endTime = performance.now();
        const timeElapsed = (endTime - startTime).toFixed(2);
        
        // Update info
        document.getElementById('info').innerHTML = `
          <strong>Results:</strong>
          <ul>
            <li>Algorithm: ${algorithm.charAt(0).toUpperCase() + algorithm.slice(1)}</li>
            <li>Number of clusters: ${nClusters}</li>
            <li>Data points: ${data.length}</li>
            <li>Time elapsed: ${timeElapsed}ms</li>
          </ul>
        `;
        
        visualizeData();
        
      } catch (error) {
        console.error('Clustering failed:', error);
        document.getElementById('info').innerHTML = 
          '<strong>Error:</strong> ' + error.message;
      } finally {
        runButton.disabled = false;
        runButton.textContent = 'Run Clustering';
      }
    }
    
    // Visualize data and clustering results
    function visualizeData() {
      const container = d3.select('#scatterChart');
      container.selectAll('*').remove();
      
      if (data.length === 0) {
        container.append('div')
          .attr('class', 'loading')
          .text('No data to display');
        return;
      }
      
      const margin = { top: 20, right: 20, bottom: 40, left: 40 };
      const width = container.node().offsetWidth - margin.left - margin.right;
      const height = 400 - margin.top - margin.bottom;
      
      const svg = container.append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);
      
      const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
      
      // Scales
      const xExtent = d3.extent(data, d => d[0]);
      const yExtent = d3.extent(data, d => d[1]);
      
      const xScale = d3.scaleLinear()
        .domain([xExtent[0] - 1, xExtent[1] + 1])
        .range([0, width]);
      
      const yScale = d3.scaleLinear()
        .domain([yExtent[0] - 1, yExtent[1] + 1])
        .range([height, 0]);
      
      // Axes
      g.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(xScale));
      
      g.append('g')
        .call(d3.axisLeft(yScale));
      
      // Plot data points
      const points = g.selectAll('.point')
        .data(data)
        .enter().append('circle')
        .attr('class', 'point')
        .attr('cx', d => xScale(d[0]))
        .attr('cy', d => yScale(d[1]))
        .attr('r', 5)
        .attr('fill', (d, i) => labels.length > 0 ? colors[labels[i]] : '#999')
        .attr('fill-opacity', 0.7)
        .attr('stroke', '#fff')
        .attr('stroke-width', 1);
      
      // Plot centroids if available (K-means)
      if (centroids.length > 0 && centroids.data) {
        const centroidData = centroids.arraySync();
        g.selectAll('.centroid')
          .data(centroidData)
          .enter().append('path')
          .attr('class', 'centroid')
          .attr('d', d3.symbol().type(d3.symbolCross).size(200))
          .attr('transform', d => `translate(${xScale(d[0])},${yScale(d[1])})`)
          .attr('fill', (d, i) => colors[i])
          .attr('stroke', '#000')
          .attr('stroke-width', 2);
      }
      
      // Update legend
      updateLegend();
    }
    
    // Update legend
    function updateLegend() {
      const legendContainer = d3.select('#legend');
      legendContainer.selectAll('*').remove();
      
      if (labels.length === 0) return;
      
      const uniqueLabels = [...new Set(labels)].sort((a, b) => a - b);
      
      uniqueLabels.forEach(label => {
        const item = legendContainer.append('div')
          .attr('class', 'legend-item');
        
        item.append('div')
          .attr('class', 'legend-color')
          .style('background-color', colors[label]);
        
        item.append('span')
          .text(`Cluster ${label + 1}`);
      });
    }
    
    // Generate new data
    function generateNewData() {
      const datasetType = document.getElementById('dataset').value;
      generateData(datasetType);
    }
    
    // Update UI based on algorithm selection
    function updateAlgorithmControls() {
      const algorithm = document.getElementById('algorithm').value;
      
      // Show/hide algorithm-specific controls
      document.getElementById('gammaControl').style.display = 
        algorithm === 'spectral' ? 'block' : 'none';
      document.getElementById('linkageControl').style.display = 
        algorithm === 'agglomerative' ? 'block' : 'none';
    }
    
    // Event listeners
    document.getElementById('algorithm').addEventListener('change', updateAlgorithmControls);
    document.getElementById('dataset').addEventListener('change', generateNewData);
    
    document.getElementById('nClusters').addEventListener('input', function(e) {
      document.getElementById('nClustersValue').textContent = e.target.value;
    });
    
    document.getElementById('gamma').addEventListener('input', function(e) {
      document.getElementById('gammaValue').textContent = e.target.value;
    });
    
    // Initialize on load
    window.addEventListener('load', async function() {
      await initializeClustering();
      generateNewData();
      updateAlgorithmControls();
    });
  </script>
</body>
</html>